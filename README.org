#+TITLE:    clj-http documentation
#+AUTHOR:   Lee Hinman
#+STARTUP:  align fold nodlcheck lognotestate showall
#+OPTIONS:  H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS:  skip:nil d:(HIDE) tags:not-in-toc auto-id:t
#+PROPERTY: header-args :results code :exports both :noweb yes
#+HTML_HEAD: <style type="text/css"> body {margin-right:15%; margin-left:15%;} </style>
#+LANGUAGE: en

* Table of Contents                                                     :TOC:
:PROPERTIES:
:CUSTOM_ID: h:aaf075ea-2f0e-4a45-871a-0f89c838fb4b
:END:
 - [[#help-wanted][HELP WANTED]]
 - [[#introduction][Introduction]]
   - [[#overview][Overview]]
   - [[#philosophy][Philosophy]]
 - [[#installation][Installation]]
 - [[#towards-a-300-release][Towards a 3.0.0 release]]
 - [[#quickstart][Quickstart]]
   - [[#head][HEAD]]
   - [[#get][GET]]
   - [[#put][PUT]]
   - [[#post][POST]]
   - [[#delete][DELETE]]
   - [[#async-http-request][Async HTTP Request]]
   - [[#coercions][Coercions]]
   - [[#headers][Headers]]
   - [[#meta-tag-headers][Meta Tag Headers]]
   - [[#link-headers][Link Headers]]
   - [[#redirects][Redirects]]
   - [[#cookies][Cookies]]
   - [[#exceptions][Exceptions]]
   - [[#decompression][Decompression]]
   - [[#debugging][Debugging]]
 - [[#authentication][Authentication]]
   - [[#basic-auth][Basic Auth]]
   - [[#digest-auth][Digest Auth]]
   - [[#oauth2][oAuth2]]
 - [[#advanced-usage][Advanced Usage]]
   - [[#raw-request][Raw Request]]
   - [[#persistent-connections][Persistent Connections]]
   - [[#proxies][Proxies]]
   - [[#custom-middleware][Custom Middleware]]
 - [[#development][Development]]
   - [[#faking-responses][Faking Responses]]
   - [[#optional-dependencies][Optional Dependencies]]
   - [[#clj-http-lite][clj-http-lite]]
   - [[#troubleshooting][Troubleshooting]]
 - [[#tests][Tests]]
 - [[#testimonials][Testimonials]]
 - [[#license][License]]

* HELP WANTED
:PROPERTIES:
:CUSTOM_ID: h:bfae0ecf-471b-438f-bf47-37c1aebea2a6
:END:
Hi Everyone,
The tests are working now, but there is a lot of work still to be done,
for instance, the connection manager code needs to be simplified, and another
pass needs to be done to see if any more deprecated APIs are in use,
so any help is appreciated!

Additionally, there are things like reusing the httpclient between
requests (perhaps only when a connection manager is used)
that need to be worked out.

If you have interest, please do send PRs for fixing.

* Introduction
:PROPERTIES:
:CUSTOM_ID: h:d893078a-b20b-4086-9272-3d9c28c86846
:END:

** Overview
:PROPERTIES:
:CUSTOM_ID: h:d8b17d06-124e-44fd-9c86-0399f39b0254
:END:

clj-http is an HTTP library wrapping the [[http://hc.apache.org/][Apache HttpComponents]] client. This
library has taken over from mmcgrana's clj-http.

[[https://secure.travis-ci.org/dakrone/clj-http.png]]

** Philosophy
:PROPERTIES:
:CUSTOM_ID: h:aa21d07d-333b-4ff2-93a9-ffdca31d8949
:END:

The design of =clj-http= is inspired by the [[https://github.com/ring-clojure/ring][Ring]] protocol for Clojure HTTP
 server applications.

The client in =clj-http.core= makes HTTP requests according to a given Ring
request map and returns [[https://github.com/ring-clojure/ring/blob/master/SPEC][Ring response maps]] corresponding to the resulting HTTP
response. The function =clj-http.client/request= uses Ring-style middleware to
layer functionality over the core HTTP request/response implementation. Methods
like =clj-http.client/get= are sugar over this =clj-http.client/request=
function.

* Installation
:PROPERTIES:
:CUSTOM_ID: h:ddfce0e2-6797-4774-add5-d5cf5bfaaa17
:END:

=clj-http= is available as a Maven artifact from [[http://clojars.org/clj-http][Clojars]].

With Leiningen/Boot:

#+BEGIN_SRC clojure
[clj-http "3.5.0"]
#+END_SRC

If you need an older version, a 2.x release is also available.

#+BEGIN_SRC clojure
[clj-http "2.3.0"]
#+END_SRC

clj-http supports clojure 1.6.0 and higher.

* Towards a 3.0.0 release
:PROPERTIES:
:CUSTOM_ID: h:adb56cf4-1034-4d81-965e-880c7315860c
:END:
So there is a 2.0 branch which is based on the latest stable version of
clj-http. Master, on the other hand, is a rewrite of the =core.clj= for the new
Apache changes (starting with 4.0 I believe) to use non-deprecated methods.
There are a number of things that need to be accomplished in order for it to be
releasable in a non-snapshot version (3.0.0+ is already on Clojars)

Here are the tests that need to pass:

- [X] =lein test clj-http.test.client-test :all=
- [X] =lein test clj-http.test.conn-mgr-test :all=
- [X] =lein test clj-http.test.cookies-test :all=
- [X] =lein test clj-http.test.core-test :all=
- [X] =lein test clj-http.test.headers-test :all=
- [X] =lein test clj-http.test.links-test :all=
- [X] =lein test clj-http.test.multipart-test :all=
- [X] =lein test clj-http.test.util-test :all=

There are still a few tests that are commented out. Any help or PRs is greatly
appreciated.

* Quickstart
:PROPERTIES:
:CUSTOM_ID: h:65f0132e-1f96-4711-a84e-973817f37dd3
:END:

The main HTTP client functionality is provided by the =clj-http.client= namespace.

First, require it in the REPL:

#+BEGIN_SRC clojure
(require '[clj-http.client :as client])
#+END_SRC

Or in your application:

#+BEGIN_SRC clojure
(ns my-app.core
  (:require [clj-http.client :as client]))
#+END_SRC

The client supports simple =get=, =head=, =put=, =post=, =delete=, =copy=,
=move=, =patch=, and =options= requests. Response are returned as [[https://github.com/ring-clojure/ring/blob/master/SPEC][Ring-style
response maps]]:

** HEAD
:PROPERTIES:
:CUSTOM_ID: h:79d1bb5f-c695-46a6-af4e-a64ca599c978
:END:

#+BEGIN_SRC clojure

(client/head "http://example.com/resource")

(client/head "http://example.com/resource" {:accept :json})

#+END_SRC

** GET
:PROPERTIES:
:CUSTOM_ID: h:89c164fb-85c2-4953-a8c4-a50867adf42a
:END:

Example requests:

#+BEGIN_SRC clojure

(client/get "http://example.com/resources/id")

(client/get "http://example.com/resources/3" {:accept :json})

;; Specifying headers as either a string or collection:
(client/get "http://example.com"
  {:headers {"foo" ["bar" "baz"], "eggplant" "quux"}})

;; Using either string or keyword header names:
(client/get "http://example.com"
  {:headers {:foo ["bar" "baz"], :eggplant "quux"}})

;; Set any specific client parameters manually:
(client/post "http://example.com"
  {:client-params {"http.protocol.allow-circular-redirects" false
                   "http.protocol.version" HttpVersion/HTTP_1_0
                   "http.useragent" "clj-http"}})

;; Set your own cookie policy
(client/post "http://example.com"
  {:client-params {:cookie-policy (fn [cookie origin] (your-validation cookie origin))}})

;; Completely ignore cookies:
(client/post "http://example.com"
  {:client-params {:cookie-policy (constantly nil)}})

;; Need to contact a server with an untrusted SSL cert?
(client/get "https://alioth.debian.org" {:insecure? true})

;; If you don't want to follow-redirects automatically:
(client/get "http://example.com/redirects-somewhere" {:follow-redirects false})

;; Only follow a certain number of redirects:
(client/get "http://example.com/redirects-somewhere" {:max-redirects 5})

;; Throw an exception if redirected too many times:
(client/get "http://example.com/redirects-somewhere" {:max-redirects 5 :throw-exceptions true})

;; Throw an exception if the get takes too long. Timeouts in milliseconds.
(client/get "http://example.com/redirects-somewhere" {:socket-timeout 1000 :conn-timeout 1000})

;; Query parameters
(client/get "http://example.com/search" {:query-params {"q" "foo, bar"}})

;; "Nested" query parameters
;; (this yields a query string of `a[e][f]=6&a[b][c]=5`)
(client/get "http://example.com/search" {:query-params {:a {:b {:c 5} :e {:f 6})

;; Provide cookies â€” uses same schema as :cookies returned in responses
;; (see the cookie store option for easy cross-request maintenance of cookies)
(client/get "http://example.com"
  {:cookies {"ring-session" {:discard true, :path "/", :value "", :version 0}}})

;; Tell clj-http not to decode cookies from the response header
(client/get "http://example.com" {:decode-cookies false})

;; Support for IPv6!
(client/get "http://[2001:62f5:9006:e472:cabd:c8ff:fee3:8ddf]")

#+END_SRC

The client will also follow redirects on the appropriate =30*= status codes.

The client transparently accepts and decompresses the =gzip= and =deflate=
content encodings.

=:trace-redirects= will contain the chain of the redirections followed.

** PUT
:PROPERTIES:
:CUSTOM_ID: h:1582cd6e-a6e8-49c8-96e3-28eee6128c31
:END:

#+BEGIN_SRC clojure

(client/put "http://example.com/api" {:body "my PUT body"})

#+END_SRC

** POST
:PROPERTIES:
:CUSTOM_ID: h:32c8ca7a-0ef2-41b8-8158-20b0e2945e5d
:END:

#+BEGIN_SRC clojure

;; Various options:
(client/post "http://example.com/api"
  {:basic-auth ["user" "pass"]
   :body "{\"json\": \"input\"}"
   :headers {"X-Api-Version" "2"}
   :content-type :json
   :socket-timeout 1000  ;; in milliseconds
   :conn-timeout 1000    ;; in milliseconds
   :accept :json})

;; Send form params as a urlencoded body (POST or PUT)
(client/post "http://example.com" {:form-params {:foo "bar"}})

;; Send form params as a json encoded body (POST or PUT)
(client/post "http://example.com" {:form-params {:foo "bar"} :content-type :json})

;; Send form params as a json encoded body (POST or PUT) with options
(client/post "http://example.com" {:form-params {:foo "bar"}
                               :content-type :json
                               :json-opts {:date-format "yyyy-MM-dd"}})

;; You can also specify the encoding of form parameters
(client/post "http://example.com" {:form-params {:foo "bar"}
                                :form-param-encoding "ISO-8859-1"})

;; Send form params as a Transit encoded JSON body (POST or PUT) with options
(client/post "http://example.com" {:form-params {:foo "bar"}
                                :content-type :transit+json
                                :transit-opts
                                {:encode {:handlers {}}
                                 :decode {:handlers {}}}})

;; Send form params as a Transit encoded MessagePack body (POST or PUT) with options
(client/post "http://example.com" {:form-params {:foo "bar"}
                                :content-type :transit+msgpack
                                :transit-opts
                                {:encode {:handlers {}}
                                 :decode {:handlers {}}}})

;; Multipart form uploads/posts
;; takes a vector of maps, to preserve the order of entities, :name
;; will be used as the part name unless :part-name is specified
(client/post "http://example.org" {:multipart [{:name "title" :content "My Awesome Picture"}
                                              {:name "Content/type" :content "image/jpeg"}
                                              {:name "foo.txt" :part-name "eggplant" :content "Eggplants"}
                                              {:name "file" :content (clojure.java.io/file "pic.jpg")}]})

;; Multipart :content values can be one of the following:
;; String, InputStream, File, a byte-array, or an instance of org.apache.http.entity.mime.content.ContentBody
;; Some Multipart bodies can also support more keys (like :encoding
;; and :mime-type), check src/clj-http/multipart.clj to see all flags

;; Apache's http client automatically retries on IOExceptions, if you
;; would like to handle these retries yourself, you can specify a
;; :retry-handler. Return true to retry, false to stop trying:
(client/post "http://example.org" {:multipart [["title" "Foo"]
                                               ["Content/type" "text/plain"]
                                               ["file" (clojure.java.io/file "/tmp/missing-file")]]
                                   :retry-handler (fn [ex try-count http-context]
                                                    (println "Got:" ex)
                                                    (if (> try-count 4) false true))})

#+END_SRC

** DELETE
:PROPERTIES:
:CUSTOM_ID: h:c7165d6b-232a-439d-9390-8c05e6ef1e6f
:END:

#+BEGIN_SRC clojure

(client/delete "http://example.com/resource")

#+END_SRC

** Async HTTP Request
:PROPERTIES:
:CUSTOM_ID: h:0e3eb987-5b2b-4874-97ef-b834394d083d
:END:
The new async HTTP request API is a Ring-style async API.
All options for synchronous request can use in asynchronous requests.
start an async request is easy, for example:

#+BEGIN_SRC clojure
;; :async? in options map need to be true
(client/get "http://example.com"
            {:async? true}
            ;; respond callback
            (fn [response] (println "response is:" response))
            ;; raise callback
            (fn [exception] (println "exception message is: " (.getMessage exception))))
#+END_SRC

All exceptions thrown during the request will be passed to the raise callback.

** Coercions
:PROPERTIES:
:CUSTOM_ID: h:8902cd95-e01e-4d9b-9dc8-5f5c8f04504b
:END:
*** Input coercion
:PROPERTIES:
:CUSTOM_ID: h:bed01743-2209-473d-ae86-bd187f059e0c
:END:

#+BEGIN_SRC clojure
;; body as a byte-array
(client/post "http://example.com/resources" {:body my-byte-array})

;; body as a string
(client/post "http://example.com/resources" {:body "string"})

;; :body-encoding is optional and defaults to "UTF-8"
(client/post "http://example.com/resources"
             {:body "string" :body-encoding "UTF-8"})

;; body as a file
(client/post "http://example.com/resources"
             {:body (clojure.java.io/file "/tmp/foo") :body-encoding "UTF-8"})

;; :length is optional for passing in an InputStream; if not
;; supplied it will default to -1 to signal to HttpClient to use
;; chunked encoding
(client/post "http://example.com/resources"
             {:body (clojure.java.io/input-stream "/tmp/foo")})

(client/post "http://example.com/resources"
             {:body (clojure.java.io/input-stream "/tmp/foo") :length 1000})
#+END_SRC

*** Output coercion
:PROPERTIES:
:CUSTOM_ID: h:0c8966a6-f220-4f1e-a79e-a520fb313f9e
:END:

#+BEGIN_SRC clojure
;; The default output is a string body
(client/get "http://example.com/foo.txt")

;; Coerce as a byte-array
(client/get "http://example.com/favicon.ico" {:as :byte-array})

;; Coerce as something other than UTF-8 string
(client/get "http://example.com/string.txt" {:as "UTF-16"})

;; Coerce as json
(client/get "http://example.com/foo.json" {:as :json})
(client/get "http://example.com/foo.json" {:as :json-strict})
(client/get "http://example.com/foo.json" {:as :json-string-keys})
(client/get "http://example.com/foo.json" {:as :json-strict-string-keys})

;; Coerce as Transit encoded JSON or MessagePack
(client/get "http://example.com/foo" {:as :transit+json})
(client/get "http://example.com/foo" {:as :transit+msgpack})

;; Coerce as a clojure datastructure
(client/get "http://example.com/foo.clj" {:as :clojure})

;; Coerce as x-www-form-urlencoded
(client/post "http://example.com/foo" {:as :x-www-form-urlencoded})

;; Try to automatically coerce the output based on the content-type
;; header (this is currently a BETA feature!). Currently supports
;; text, json and clojure (with automatic charset detection)
;; clojure coercion requires "application/clojure" or
;; "application/edn" in the content-type header
(client/get "http://example.com/foo.json" {:as :auto})

;; Return the body as a stream
(client/get "http://example.com/bigrequest.html" {:as :stream})
;; Note that the connection to the server will NOT be closed until the
;; stream has been read
#+END_SRC

Output coercion with =:as :json=, =:as :json-strict=, =:as :json-strict-string-keys=, =:as :json-string-keys= or =:as :x-www-form-urlencoded= will only work with an optional dependency, see [[#optional-dependencies][Optional Dependencies]].

JSON coercion defaults to only an "unexceptional" statuses, meaning status codes
in the #{200 201 202 203 204 205 206 207 300 301 302 303 307} range. If you
would like to change this, you can send the =:coerce= option, which can be set
to:

#+BEGIN_SRC clojure
:always        ;; always json decode the body
:unexceptional ;; only json decode when not an HTTP error response
:exceptional   ;; only json decode when it IS an HTTP error response
#+END_SRC

The =:coerce= setting defaults to =:unexceptional=.

** Headers
:PROPERTIES:
:CUSTOM_ID: h:ef64574f-f9dc-4356-95b7-d55cc6737b44
:END:

clj-http's treatment of headers is a little more permissive than the [[https://github.com/ring-clojure/ring/blob/master/SPEC][ring spec]]
specifies.

Rather than forcing all request headers to be lowercase strings,
clj-http allows strings or keywords of any case. Keywords will be
transformed into their canonical representation, so the :content-md5
header will be sent to the server as "Content-MD5", for instance.
String keys in request headers, however, will be sent to the server
with their casing unchanged.

Response headers can be read as keywords or strings of any case. If
the server responds with a "Date" header, you could access the value
of that header as :date, "date", "Date", etc.

If for some reason you require access to the original header name that
the server specified, it is available by invoking (keys ...) on the
header map.

This special treatment of headers is implemented in the
wrap-header-map middleware, which (like any middleware) can be
disabled by using with-middleware to specify different behavior.

** Query-string parameters
:PROPERTIES:
:CUSTOM_ID: h:dd49992c-a516-4af0-9735-4f4340773361
:END:

There are three different ways that query string parameters for array values can
be generated, depending on what the resulting query string should look like,
they are:

- A repeating parameter (default)
- Array style
- Indexed array style

Here is an example of the input and output for the ~:query_string~ parameter,
controlled by the ~:multi-param-style~ option:

#+BEGIN_SRC clojure
;; default style, with :multi-param-style unset
:a [1 2 3] => "a=1&a=2&a=3"
;; with :multi-param-style :array, a repeating param with array suffix
;; (PHP-style):
:a [1 2 3] => "a[]=1&a[]=2&a[]=3"
;; with :multi-param-style :indexed, a repeating param with array suffix and
;; index (Rails-style):
:a [1 2 3] => "a[0]=1&a[1]=2&a[2]=3"
#+END_SRC

** Meta Tag Headers
:PROPERTIES:
:CUSTOM_ID: h:01663a63-8bc8-45da-8a3d-341402f3f3fa
:END:

HTML 4.01 allows using the tag ~<meta http-equiv="..." />~ and HTML 5 allows
using the tag ~<meta charset="..." />~ to specify a header that should be
treated as an HTTP response header. By default, clj-http will ignore the body of
the response (other than the regular output coercion), but if you need clj-http
to parse the headers out of the body, you can use the =:decode-body-headers=
option:

#+BEGIN_SRC clojure
;; without decoding body headers (defaults to off):
(:headers (client/get "http://www.yomiuri.co.jp/"))
=> {"server" "Apache",
    "content-encoding" "gzip",
    "content-type" "text/html",
    "date" "Tue, 09 Oct 2012 18:02:41 GMT",
    "cache-control" "max-age=0, no-cache",
    "expires" "Tue, 09 Oct 2012 18:02:41 GMT",
    "etag" "\"1dfb-2686-4cba2686fb8b1\"",
    "pragma" "no-cache",
    "connection" "close"}

;; with decoding body headers, notice the content-type,
;; content-style-type and content-script-type headers:
(:headers (client/get "http://www.yomiuri.co.jp/" {:decode-body-headers true}))
=> {"server" "Apache",
    "content-encoding" "gzip",
    "content-script-type" "text/javascript",
    "content-style-type" "text/css",
    "content-type" "text/html; charset=Shift_JIS",
    "date" "Tue, 09 Oct 2012 18:02:59 GMT",
    "cache-control" "max-age=0, no-cache",
    "expires" "Tue, 09 Oct 2012 18:02:59 GMT",
    "etag" "\"1dfb-2686-4cba2686fb8b1\"",
    "pragma" "no-cache",
    "connection" "close"}
#+END_SRC

This can be used to have clj-http correctly interpret the body's charset by
using:

#+BEGIN_SRC clojure
(client/get "http://www.yomiuri.co.jp/" {:decode-body-headers true :as :auto})
=> ;; correctly formatted :body (Shift_JIS charset instead of UTF-8)
#+END_SRC

Note that this feature is currently beta and uses [[https://github.com/weavejester/crouton][Crouton]] to parse the body of
the request. If you do not want to use this feature, you can include Crouton in
addition to clj-http as a dependency like so:

#+BEGIN_SRC clojure
(defproject foo "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.3.0"]
                 [clj-http "0.6.0"]
                 [crouton "1.0.0"]])
#+END_SRC

Note also that HEAD requests will not return a body, in which case this setting will have no effect.

clj-http will automatically disable the =:decode-body-headers= option.

** Link Headers
:PROPERTIES:
:CUSTOM_ID: h:f7464c54-4928-474f-9132-08e6b6f3c19d
:END:

clj-http parses any [[http://tools.ietf.org/html/rfc5988][link headers]] returned in the response, and adds them to the
=:links= key on the response map. This is particularly useful for paging RESTful
APIs:

#+BEGIN_SRC clojure
(:links (client/get "https://api.github.com/gists"))
=> {:next {:href "https://api.github.com/gists?page=2"}
    :last {:href "https://api.github.com/gists?page=22884"}}
#+END_SRC

** Redirects
:PROPERTIES:
:CUSTOM_ID: h:71c966ae-f764-4bd7-801c-0f3c8413c502
:END:

clj-http conforms its behaviour regarding automatic redirects to the [[https://tools.ietf.org/html/rfc2616#section-10.3][RFC]].

It means that redirects on status =301=, =302= and =307= are not redirected on
methods other than =GET= and =HEAD=. If you want a behaviour closer to what most
browser have, you can set =:force-redirects= to =true= in your request to have
automatic redirection work on all methods by transforming the method of the
request to =GET=.

** Cookies
:PROPERTIES:
:CUSTOM_ID: h:3bb89b16-4be3-455e-98ec-c5ca5830ddb9
:END:

*** Cookiestores
:PROPERTIES:
:CUSTOM_ID: h:1d86fe30-f690-4c2a-9a1c-231669f4591a
:END:

clj-http can simplify the maintenance of cookies across requests if it is
provided with a _cookie store_.

#+BEGIN_SRC clojure
(binding [clj-http.core/*cookie-store* (clj-http.cookies/cookie-store)]
  (client/post "http://example.com/login" {:form-params {:username "..."
                                                      :password "..."}})
  (client/get "http://example.com/secured-page")
  ...)
#+END_SRC

(The =clj-http.cookies/cookie-store= function returns a new empty instance of a
default implementation of =org.apache.http.client.CookieStore=.)

This will allow cookies to only be _written_ to the cookie store. Cookies from
the cookie-store will not automatically be sent with future requests.

If you would like cookies from the cookie-store to automatically be sent with
each request, specify the cookie-store with the =:cookie-store= option:

#+BEGIN_SRC clojure
(let [my-cs (clj-http.cookies/cookie-store)]
  (client/post "http://example.com/login" {:form-params {:username "..."
                                                      :password "..."}
                                        :cookie-store my-cs})
  (client/post "http://example.com/update" {:body my-data
                                         :cookie-store my-cs}))
#+END_SRC

You can also us the =get-cookies= function to retrieve the cookies
from a cookie store:

#+BEGIN_SRC clojure
(def cs (clj-http.cookies/cookie-store))

(client/get "http://google.com" {:cookie-store cs})

(clojure.pprint/pprint (clj-http.cookies/get-cookies cs))
{"NID"
 {:domain ".google.com",
  :expires #<Date Tue Oct 02 10:12:06 MDT 2012>,
  :path "/",
  :value
  "58=c387....",
  :version 0},
 "PREF"
 {:domain ".google.com",
  :expires #<Date Wed Apr 02 10:12:06 MDT 2014>,
  :path "/",
  :value
  "ID=3ba...:FF=0:TM=133...:LM=133...:S=_iRM...",
  :version 0}}
#+END_SRC

*** Keystores, Trust-stores
:PROPERTIES:
:CUSTOM_ID: h:7968467a-1441-4a73-9307-9a7a5fd8e733
:END:

You can also specify your own keystore/trust-store to be used:

#+BEGIN_SRC clojure
(client/get "https://example.com" {:keystore "/path/to/keystore.ks"
                                   :keystore-type "jks" ; default: jks
                                   :keystore-pass "secretpass"
                                   :trust-store "/path/to/trust-store.ks"
                                   :trust-store-type "jks" ; default jks
                                   :trust-store-pass "trustpass"})
#+END_SRC

The =:keystore/:trust-store= values may be either paths to keystore
files or =KeyStore= instances.

** Exceptions
:PROPERTIES:
:CUSTOM_ID: h:ed9e04f1-1c7b-4c2e-9259-94d2a3e65a89
:END:

The client will throw exceptions on, well, exceptional status codes, meaning all
HTTP responses other than =#{200 201 202 203 204 205 206 207 300 301 302 303
307}=. clj-http will throw a [[http://github.com/scgilardi/slingshot][Slingshot]] Stone that can be caught by a regular
=(catch Exception e ...)= or in Slingshot's =try+= block:

#+BEGIN_SRC clojure
(client/get "http://example.com/broken")
=> ExceptionInfo clj-http: status 404  clj-http.client/wrap-exceptions/fn--583 (client.clj:41)
;; Or, if you would like the Exception message to contain the entire response:
(client/get "http://example.com/broken" {:throw-entire-message? true})
=> ExceptionInfo clj-http: status 404 {:status 404,
                                       :headers {"server" "nginx/1.0.4",
                                                 "x-runtime" "12ms",
                                                 "content-encoding" "gzip",
                                                 "content-type" "text/html; charset=utf-8",
                                                 "date" "Mon, 17 Oct 2011 23:15 :36 GMT",
                                                 "cache-control" "no-cache",
                                                 "status" "404 Not Found",
                                                 "transfer-encoding" "chunked",
                                                 "connection" "close"},
                                       :body "...body here..."}
   clj-http.client/wrap-exceptions/fn--584 (client.clj:42

;; You can also ignore HTTP-status-code exceptions and handle them yourself:
(client/get "http://example.com/broken" {:throw-exceptions false})
;; Or ignore an unknown host (methods return 'nil' if this is set to
;; true and the host does not exist:
(client/get "http://example.invalid" {:ignore-unknown-host? true})
#+END_SRC

(spacing added by me to be human readable)

How to use with Slingshot:

#+BEGIN_SRC clojure
; Response map is thrown as exception obj.
; We filter out by status codes
(try+
  (client/get "http://example.com/broken")
  (catch [:status 403] {:keys [request-time headers body]}
    (log/warn "403" request-time headers))
  (catch [:status 404] {:keys [request-time headers body]}
    (log/warn "NOT Found 404" request-time headers body))
  (catch Object _
    (log/error (:throwable &throw-context) "unexpected error")
    (throw+)))
#+END_SRC

** Decompression
:PROPERTIES:
:CUSTOM_ID: h:f780c96c-90be-4d83-9b53-227a9e5942ab
:END:

By default, clj-http will add the ={"Accept-Encoding" "gzip, deflate"}= header
to requests, and automatically decompress the resulting gzip or deflate stream
if the =Content-Encoding= header is found on the response. If this is undesired,
the ={:decompress-body false}= option can be specified:

#+BEGIN_SRC clojure
;; Auto-decompression used: (google requires a user-agent to send gzip data)
(def h {"User-Agent" "Mozilla/5.0 (Windows NT 6.1;) Gecko/20100101 Firefox/13.0.1"})
(def resp (client/get "http://google.com" {:headers h}))
(:orig-content-encoding resp)
=> "gzip" ;; <= google sent response gzipped

;; and without decompression:
(def resp2 (client/get "http://google.com" {:headers h :decompress-body false})
(:orig-content-encoding resp2)
=> nil
#+END_SRC

If clj-http decompresses something, the "content-encoding" header is removed
from the headers (because the encoding is no longer true). This allows clj-http
to be used as a pass-through proxy with ring. The original content-encoding is
available as =:orig-content-encoding= in the response map if auto-decompression
is enabled.

** Debugging
:PROPERTIES:
:CUSTOM_ID: h:d2043bd3-5d97-416a-858d-a7936ff61c50
:END:

There are four debugging methods you can use:

#+BEGIN_SRC clojure
;; print request info to *out*:
(client/get "http://example.org" {:debug true})

;; print request info to *out*, including request body:
(client/post "http://example.org" {:debug true :debug-body true :body "..."})

;; save the request that was sent in a :request key in the response:
(client/get "http://example.org" {:save-request? true})

;; save the request that was sent in a :request key in the response,
;; including the body content:
(client/get "http://example.org" {:save-request? true :debug-body true})

;; add an HttpResponseInterceptor to the request. This callback
;; is called for each redirects with the following args:
;; ^HttpResponse resp, HttpContext^ ctx
;; this allows low level debugging + access to socket.
;; see http://hc.apache.org/httpcomponents-core-ga/httpcore/apidocs/org/apache/http/HttpResponseInterceptor.html
(client/get "http://example.org" {:response-interceptor (fn [resp ctx] (println ctx))})
#+END_SRC

* Authentication
:PROPERTIES:
:CUSTOM_ID: h:87f38469-36b4-44c6-ae74-0d8f5e80c2ed
:END:

** Basic Auth
:PROPERTIES:
:CUSTOM_ID: h:d3ea348f-88ed-4193-bb16-d8d5accdc2aa
:END:

#+BEGIN_SRC clojure

(client/get "http://example.com/protected" {:basic-auth ["user" "pass"]})
(client/get "http://example.com/protected" {:basic-auth "user:pass"})

#+END_SRC

** Digest Auth
:PROPERTIES:
:CUSTOM_ID: h:d1904589-e71e-43db-8b93-0f94ccecaabe
:END:

#+BEGIN_SRC clojure

(client/get "http://example.com/protected" {:digest-auth ["user" "pass"]})

#+END_SRC

** oAuth2
:PROPERTIES:
:CUSTOM_ID: h:dd077440-a1de-437e-b34e-5d6d0d1da4bd
:END:

#+BEGIN_SRC clojure

(client/get "http://example.com/protected" {:oauth-token "secret-token"})

#+END_SRC

* Advanced Usage
:PROPERTIES:
:CUSTOM_ID: h:d52ca837-a575-402f-81fe-53241d85f2db
:END:

** Raw Request
:PROPERTIES:
:CUSTOM_ID: h:0d2eadbf-c1ad-4514-a932-9d173582a790
:END:

A more general =request= function is also available, which is useful as a
primitive for building higher-level interfaces:

#+BEGIN_SRC clojure
(defn api-action [method path & [opts]]
  (client/request
    (merge {:method method :url (str "http://example.com/" path)} opts)))
#+END_SRC

*** Boolean options
:PROPERTIES:
:CUSTOM_ID: h:a37c718c-43bb-43ce-936a-21ef65147295
:END:

Since 0.9.0, all boolean options can be expressed as either ={:debug true}= or
={:debug? true}=, with or without the question mark.

** Persistent Connections
:PROPERTIES:
:CUSTOM_ID: h:4e9f116d-c293-4a0c-8e11-435c440bfe97
:END:

clj-http can use persistent connections to speed up connections if multiple
connections are being used:

#+BEGIN_SRC clojure
(with-connection-pool {:timeout 5 :threads 4 :insecure? false :default-per-route 10}
  (get "http://example.org/1")
  (post "http://example.org/2")
  (get "http://example.org/3")
  ...
  (get "http://example.org/999"))
#+END_SRC

For async request, you can use =with-async-connection-pool=

#+BEGIN_SRC clojure
(with-async-connection-pool {:timeout 5 :threads 4 :insecure? false :default-per-route 10}
  (get "http://example.org/1" {:async? true} resp1 exce1)
  (post "http://example.org/2" {:async? true} resp2 exce2)
  (get "http://example.org/3" {:async? true} resp3 exce3)
  ...
  (get "http://example.org/999" {:async? true} resp999 exce999))
#+END_SRC

This is MUCH faster than sequentially performing all requests, because a
persistent connection can be used instead creating a new connection for each
request.

If you want to start an async request in the =respond= callback of an async request and
reuse the pool context, just use =reuse-pool=.

#+BEGIN_SRC clojure
(with-async-connection-pool {:timeout 5 :threads 4 :insecure? false :default-per-route 10}
  (get "http://example.org/1" {:async? true} resp1 exce1)
  (post "http://example.org/2"
        {:async? true}
        (fn [resp] (get "http://example.org/3"
                        (reuse-pool {:async? true} resp)
                        resp3 exce3))
        exce2))
#+END_SRC

To implement the persistent connections of async requests, we add a middleware
named =wrap-async-pooling= to the default middleware list. This middleware's
behaviour depends on =*pooling-info*= binding or =:polling-info= in options map.
The =pooling-info= contains =:conn-mgr=, =:allocate= and =:release=.
=:conn-mgr= is the connection manager used in the pooling context, =:allocate=
is a function will be invoked when request start and =:release= will be invoked
when request finished.

=with-async-connection-pool= use the =wrap-async-pooling= to manage the
connection manager, you can also implement your manage strategy.

If you would prefer to handle managing the connection manager yourself, you can
create a connection manager yourself and specify it for each request:

#+BEGIN_SRC clojure
(def cm (clj-http.conn-mgr/make-reusable-conn-manager {:timeout 2 :threads 3}))
(def cm2 (clj-http.conn-mgr/make-reusable-conn-manager {:timeout 10 :threads 1}))

(get "http://example.org/1" {:connection-manager cm2})
(post "http://example.org/2" {:connection-manager cm})
(get "http://example.org/3" {:connection-manager cm2})

;; Don't forget to shut it down when you're done!
(clj-http.conn-mgr/shutdown-manager cm)
(clj-http.conn-mgr/shutdown-manager cm2)
#+END_SRC

See the docstring on =make-reusable-conn-manager= for options and default
values.

In current version, pooled async request CANNOT specify connection manager.

** Proxies
:PROPERTIES:
:CUSTOM_ID: h:49f9ca81-0bad-4cd8-87ac-c09a85fa5500
:END:

A proxy can be specified by setting the Java properties: =<scheme>.proxyHost=
and =<scheme>.proxyPort= where =<scheme>= is the client scheme used (normally
'http' or 'https'). =http.nonProxyHosts= allows you to specify a pattern for
hostnames which do not require proxy routing - this is shared for all schemes.
Additionally, per-request proxies can be specified with the =proxy-host= and
=proxy-port= options (this overrides =http.nonProxyHosts= too):

#+BEGIN_SRC clojure
(client/get "http://example.com" {:proxy-host "127.0.0.1" :proxy-port 8118})
#+END_SRC

You can also specify the =proxy-ignore-hosts= parameter with a list of
hosts where the proxy should be ignored. By default this list is
=#{"localhost" "127.0.0.1"}=.

A SOCKS proxy can be used by creating a proxied connection manager with
=clj-http.conn-mgr/make-socks-proxied-conn-manager=. Then using that connection
manager in the request.

For example if you wanted to connect to a local socks proxy on port =8081= you
would:

#+BEGIN_SRC clojure
(ns foo.bar
  (:require [clj-http.client :as client]
            [clj-http.conn-mgr :as conn-mgr]))

(client/get "https://google.com"
            {:connection-manager
             (conn-mgr/make-socks-proxied-conn-manager "localhost" 8081)})
#+END_SRC

You can also store the proxied connection manager and reuse it later.

** Custom Middleware
:PROPERTIES:
:CUSTOM_ID: h:c51cba6c-5c1b-4941-93c3-f769bb533562
:END:

Sometime it is desirable to run a request with some middleware enabled and some
left out, the =with-middleware= method provides this functionality:

#+BEGIN_SRC clojure
(with-middleware [#'clj-http.client/wrap-method
                  #'clj-http.client/wrap-url
                  #'clj-http.client/wrap-exceptions]
  (get "http://example.com")
  (post "http://example.com/foo" {:body (.getBytes "foo")}))
#+END_SRC

To see available middleware, check the =clj-http.client/default-middleware= var,
which is a vector of the default middleware that clj-http uses.
=clj-http.client/*current-middleware*= is bound to the current list of
middleware during request time.

* Development
:PROPERTIES:
:CUSTOM_ID: h:65bbf017-2e8b-4c43-824b-24b89cc27a70
:END:

Please send a pull request or open an issue if you have any problems.

** Faking Responses
:PROPERTIES:
:CUSTOM_ID: h:c3d9c7e0-cc3f-47bf-91e3-b12567b08eb6
:END:

If you need to fake clj-http responses (for things like testing and such), check
out the [[https://github.com/myfreeweb/clj-http-fake][clj-http-fake]] library.

** Optional Dependencies
:PROPERTIES:
:CUSTOM_ID: h:f1fbdad3-cf40-41e0-8ae0-8716419be228
:END:

In 2.0.0+ clj-http's optional dependencies at excluded by default, in order to
use the features you will need to add them to your =project.clj= file.

clj-http currently has four optional dependencies, =cheshire=, =crouton=,
=tools.reader= and =ring/ring-codec=. Any number of them may be included by
adding them with the clj-http dependency in your project.clj:

#+BEGIN_SRC clojure
;; optional dependencies
[cheshire] ;; for :as :json
[crouton] ;; for :decode-body-headers
[org.clojure/tools.reader] ;; for :as :clojure
[ring/ring-codec] ;; for :as :x-www-form-urlencoded
#+END_SRC

Prior to 2.0.0, you can /exclude/ the dependencies and clj-http will work
without them.

** clj-http-lite
:PROPERTIES:
:CUSTOM_ID: h:ba6b263b-74a5-40f3-afc1-b0d785554c2b
:END:

Like clj-http but need something more lightweight without as many external
dependencies? Check out [[https://github.com/hiredman/clj-http-lite][clj-http-lite]] for a project that can be used as a
drop-in replacement for clj-http.

** Troubleshooting
:PROPERTIES:
:CUSTOM_ID: h:c543201e-a0e5-4e84-8eb2-6bf3e21a3140
:END:
*** VerifyError class org.codehaus.jackson.smile.SmileParser overrides final method getBinaryValue...
:PROPERTIES:
:CUSTOM_ID: h:c3a8ebc3-a247-4327-8b71-0097d1380873
:END:

This is actually caused by your project attempting to use [[https://github.com/mmcgrana/clj-json/][clj-json]] and [[https://github.com/dakrone/cheshire][cheshire]]
in the same classloader. You can fix the issue by either not using clj-json (and
thus choosing cheshire), or specifying an exclusion for clj-http in your project
like this:

#+BEGIN_SRC clojure
(defproject foo "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.3.0"]
                 [clj-http "0.3.4" :exclusions [cheshire]]])
#+END_SRC

Note that if you exclude cheshire, json decoding of response bodies
and json encoding of form-params cannot happen, you are responsible
for your own encoding/decoding.

As of clj-http 0.3.5, you should no longer see this, as Cheshire 3.1.0
and clj-json can now live together without causing problems.

*** NoHttpResponseException ... due to stale connections**
:PROPERTIES:
:CUSTOM_ID: h:9d7cf050-ed5b-4d23-8b02-97a9b9c94737
:END:

Persistent connections kept alive by the connection manager become stale: the
target server shuts down the connection on its end without HttpClient being able
to react to that event, while the connection is being idle, thus rendering the
connection half-closed or 'stale'.

This can be solved by using (with-connection-pool) as described in the
'Using Persistent Connection' section above.

* Tests
:PROPERTIES:
:CUSTOM_ID: h:a52feb3d-d966-4287-a07e-ad7aa7918fd5
:END:

To run the tests:

#+BEGIN_SRC
$ lein deps
$ lein test

Run all tests (including integration):
$ lein test :all

Run tests against 1.2.1, 1.3 and 1.4
$ lein all test
$ lein all test :all
#+END_SRC

* Testimonials
:PROPERTIES:
:CUSTOM_ID: h:3044d1f7-6772-43c2-9ded-8c71c7f9ada2
:END:

With close to a [[https://clojars.org/clj-http][million]] downloads, clj-http is a
widely used, battle-tested clojure library. It is also included in other
libraries (like database clients) as a low-level http wrapper.

Libraries using clj-http:

- [[https://github.com/mattrepl/clj-oauth][clj-oauth]]
- [[https://github.com/clojurewerkz/elastisch][elasticsearch]]
- [[https://github.com/olauzon/capacitor][influxdb]]

Libraries inspired by clj-http:

- [[https://github.com/mpenet/jet][jet]]
- [[https://github.com/hiredman/clj-http-lite][clj-http-lite]]

* License
:PROPERTIES:
:CUSTOM_ID: h:2de3db75-7a1b-42b8-ad3b-6ef27fc2a5ea
:END:

Released under the MIT License:
<http://www.opensource.org/licenses/mit-license.php>
